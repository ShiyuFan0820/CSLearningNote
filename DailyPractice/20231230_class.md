# Class

**Exercise: Pong Game (Updating)**
1. Pong Game is a game similar to Ping Pong.
2. Create a screen and draw a paddle at either left or right sides.
3. The ball bounces on the left and right sides of the screen.
4. Paddle side represents user the other side is computer, and the user can control the movement of the paddle by keys.
5. The paddle can only move up and down to catch the ball, if the user catch the ball, their score will add one point if not the game is over.
6. If the ball hits the paddle or wall on the opposite side of the paddle, it will bounce in the opposite direction.

**Collipse the challenge into small blocks:**
1. Create a screen, set up the screen size and color.
2. Create a `Paddle` class to draw the paddle, and define methods to make the paddle move.
3. Create a `Ball` class to draw a ball on the screen and make it bounce on the screen.
4. Detect the collision of the paddle and ball, create a score record class to show the score.

**The code is:**
```py
from turtle import Screen
from Paddle import Paddle
from Ball import Ball
import time


# Create the screen.
screen = Screen()
screen.setup(800, 600)
screen.bgcolor("black")
screen.title("Pong Game")
screen.tracer(0)


# Create the paddle class.
class Paddle(Turtle):
    def __init__(self, position):
        super().__init__()
        self.shape("square")
        self.penup()
        self.shapesize(stretch_wid=5, stretch_len=1)
        self.color("white")
        self.goto(position)

    def move_up(self):
        new_y = self.ycor() + 20
        self.goto(self.xcor(), new_y)

    def move_down(self):
        new_y = self.ycor() - 20
        self.goto(self.xcor(), new_y)


# Create the ball class.
class Ball(Turtle):
    def __init__(self):
        super().__init__()
        self.shape("circle")
        self.color("white")
        self.penup()
        self.x_move = 10
        self.y_move = 10

    def move(self):
        new_x = self.xcor() + self.x_move
        new_y = self.ycor() + self.y_move
        self.goto(new_x, new_y)

    def x_bounce(self):
        self.x_move *= -1

    def y_bounce(self):
        self.y_move *= -1


# Create the paddle and ball objects.
r_paddle = Paddle((360, 0))
ball = Ball()
# Control the paddle with keys.
screen.listen()
screen.onkey(r_paddle.move_up, "Up")
screen.onkey(r_paddle.move_down, "Down")

is_game_on = True
while is_game_on:
    time.sleep(0.06)
    screen.update()
    ball.move()
    # Detect collision with walls.
    if ball.ycor() > 370 or ball.ycor() < -360:
        ball.y_bounce()
    # Detect collision with paddles.
    if ball.distance(r_paddle) < 30 and ball.xcor() < -380:
        ball.x_bounce()


screen.exitonclick()

```

_**Issues Recorded:**_  
_1. The `bounce()` method in `Ball` class has no response._  
_My code was written as below at first:_
```py
is_game_on = True
while is_game_on:
    time.sleep(0.06)
    screen.update()
    if ball.xcor() < 380:
        ball.move()
    # Detect the collision with walls.
    else:
        ball.bounce()
```
_The reason the `bounce()` has no response is that in the while loop, `if ball.xcor() < 380` will first be detected, if the x cordination is greater than 380, the `ball.bounce()` will run once, and the while loop will start again, but in this round, after the first `ball.bounce()` has excuted, the x cordination is already less than 380, it will run `ball.move()`, and this causes these two functions to alternate all the time, the ball will not bounce constantly in the opposite direction, to solve this problem, the number of steps can be changed to a negative number, this will allow cordination to continue to decrease and thus achieve the purpose of the bounce._

_2. The ball only bounce in a straight line._  
_My code was written as below at first:_
```py
    # The part of the ball class
    def move(self):
        new_x = self.xcor() + self.ball_move # self.ball_move = 10
        new_y = self.ycor() + self.ball_move
        self.goto(new_x, new_y)

    def bounce(self):
        self.ball_move *= -1


    # Detect part: Detect collision with walls.
    if ball.ycor() > 370 or ball.ycor() < -360:
        ball.bounce()
    # Detect part: Detect collision with paddles.
    if ball.distance(r_paddle) < 30:
        ball.bounce()
```
_In the game, the ball bounces when it hits the walls and the paddles, and the cordination of the bounce are determined by the collision, but when I actually run the code, whether it hits the walls or the paddles, the return path is the same line, it is becuase the x and y cordination of `move()` method and `bounce()` method both increase and or decrease at the same time, so the ball will always move on the same line, to solve this problem, the x and y cordination can be listed separately, changing the x or y cordination when these of the ball cross a boundary or hit a paddle._





